---
layout: post
title: 关于递归的笔记
date: 2018-10-29 13:53:20 +0300
description: 关于递归的笔记. # Add post description (optional)
img: # Add image post (optional)
tags: [javascript,recursion]
---

##### 递归的计算过程和迭代的计算过程
递归，就是一个函数直接或者间接地调用自身的形式。递归计算过程的基本思想是利用问题的自相似性，把问题拆分成一个基本元素和一个子问题，解决基本元素，然后在子问题上重复这个过程，直到问题无法再分解。

与之对应的是迭代，迭代计算过程的基本思路是维持一个指针来索引数据集上的数据元素，同时维持一个状态来保存计算的结果。随着指针遍历数据集，在数据上执行计算，根据每次计算的结果来更新计算结果，直到遍历完数据集，计算结果里保存的最终的计算结果。

但是，递归的形式写出来的过程不一定是递归的计算过程。以计算一个整数的阶乘为例，

递归的外表，递归计算过程的写法是（1）：

```
const fact = (n) => {
  if(n == 0){
    return 1
  }
  else{
    return n * fact(n - 1)
  }
}
```

迭代的外表，迭代的计算过程的写法是（2）：

```
const fact = (n) => {
  if(n == 0){
    return 1
  } 
  else{
    let result = 1;
    for(let i = 1; i <= n; i++){
      result = result * i
    }
    return result
  }
}
```

递归的外表，迭代的计算过程的写法是（3）：

```
const fact = (n) => {
   const factIter = (n, result) => {
     if(n == 0){
       return result
     }
     else{
       return factIter(n - 1, result * n)
     }
   }
   return factIter(n, 1)
}
```

比较1和2可以很明显地看出递归和迭代的区别，以计算fact(3)为例，把1的计算过程逐步展开，可以把计算的过程表示如下：

```
fact(3)
3 * fact(2)
3 * 2 * fact(1)
3 * 2 * 1 * fact(0)
3 * 2 * 1 * 1
6
```
计算的过程中，每执行一次调用，都要保存当前的结果，维持一个调用栈，那么当递归的层数太深的时候，就会出现栈溢出的情况。

但是把2的计算过程展开后，计算的过程可以表示如下，以`(i, result)`的形式描述计算过程中状态的变化：

```
(1, 1)
(2, 1 * 2)
(3, 1 * 2 * 3)
```
可以看出，迭代的计算过程中，始终只需要维持一个变量，随着计算的进行，不会产生额外的栈空间需求。这种差别大概是递归计算过程和迭代计算过程最直观的区别了。

从这个角度来看3的计算过程：

```
fact(3, 1)
fact(2, 1 * 3)
fact(1, 1 * 3 * 2)
fact(0, 1 * 3 * 2) => 6
```

如果有尾递归优化的支持，3虽然是递归的写法，但是计算的过程和2却是一样的。这就说明递归的形式和递归的计算过程是两码事。

##### 尾递归
当一个函数的最后一个语句或者表达式是一个函数调用时，称这种情形为尾调用，简单的说就是下面所说的这种情形：

```
const f = () => {
  ...
  g(temp)
}
```

可以看出，这种情形的计算，当执行到f的最后，不需要为g的调用开辟新的栈空间，因为g计算所需要的状态已经随着f计算的结束，保存在栈里了。用特殊的编译优化是可以实现这种效果的。一种更特殊的情形是，尾调用调用的函数自身，那么就成了递归，而且，这种递归称为尾递归。结合尾调用的编译优化，尾递归可以在递归的形式下实现迭代的语义，实现理论上无限层深的递归，而不会产生栈溢出。当然，这些好处的前提是语言的编译或者执行实现了尾递归优化，es6中的一个特性就是为javascript提供尾递归优化的支持。尾递归也叫“伪递归”，因为它虽然用着递归的形式，实际上却是迭代的计算过程。

这种吃力不讨好的写法在javascript中看起来很多余，没有什么用。但是在一些函数式的语言中，没有提供迭代的语法，迭代是基本的结构，为了避免栈溢出的情形，尾递归的写法就非常必要了。例如在scheme中，阶乘一般是这样实现的：

```
(define fact
    (lambda (n)
      (define fact-iter
        (lambda (n result)
          (cond
            ((zero? n) result)
            (else (fact-iter (- n 1) (* n result))))))
      (fact-iter n 1)))
```

或者，通过编译的技术，利用cps变换可以把一些递归的函数自动转换为尾递归的形式。之前王垠那个厉害得不行的[40行代码](https://github.com/yinwang0/lightsabers/blob/6a66c294d4c4217efebfdeae18ee4697d802f79e/cps.ss)就是做了这件事情。所以，尾递归优化的意义在于用递归的语法可以实现迭代的语义，有很强的理论上的意义，但是实际的开发中，尤其在有迭代语法支持的情况下，写成尾递归的形式也不会带来什么好处。

##### CPS
对比尾调用，cps或许是更重要的东西。cps是`Continuation Passing Style`的缩写，是一种编程风格`Continuation`可以理解为将要进行的计算过程，那么cps的字面意思就是传递将要进行的计算过程的风格。计算过程在javascript中可以抽象为函数，那么cps就是在任何一个计算过程的结尾，把当前的结果传递给`Continuation`继续计算。以一个简单的例子说明：

```
const f = (x, y) => x + y
const print = console.log
const temp = f(2, 3)
print(temp)
```

这一段程序描述的是计算2+3，然后打印计算的结果这个计算过程。在cps风格下，它是这样的：

```
const f = (x, y, g) => g(x + y)
f(2, 3, print)
```

可以看出，在cps风格下，程序会非常自然地变成尾调用的形式，一旦成为了尾调用的形式，就可以做尾调用优化，所以，对程序进行cps变换是函数式语言中一项非常重要的技术。在javascript中，cps几乎是天然的随处可见：

```
f(x, function(y){
  g(y, function(z){
    h(z, function(w){
      ...
    })
  })
})
```

这种事件回调的写法，我们太熟悉了。

在cps的视角看，同步和异步在形式上是统一的。一个非常大的区别是，在异步情形下，回调函数（`Continuation`）的执行时机是无法预测的，由运行时决定。但是同步的场景下，`Continuation`是可以预测地立即执行的。

再来看promise，promise就是`Continuation`的一种特殊的表现形式。它把上一次的计算结果包装起来，然后暴露出一个接口(`then`)来插入`Continuation`，计算就这么继续了下去。与回调函数不同的是，promise给了开发者对`Continuation`更强的控制权：不仅能够控制下一步计算的内容，还可以一定程度上控制这个计算过程发生的事件。只有显式地调用了`then`，`Continuation`才会继续计算过程。而回调函数的形式下，我们只能控制下一步计算的内容（回调函数），对于执行的时机，是没有办法控制的。

而yield则为开发者提供了对`Continuation`更强的控制。promise的状态无法重入，但是yield则提供了一种机制让开发者可以自定义一个计算过程的计算策略。每当执行到yield时，运行时就把当前的`Continuation`保存起来，然后将计算的结果返回。直到下一次调用next时，运行时取出栈空间上的`Continuation`，继续计算的过程。

在scheme中，还有一个更强大的结构，就叫`Continuation`，scheme提供了call/cc这个过程可以在函数执行的任何一个时间点获取计算的`Continuation`，保存为一个变量，而且，这个`Continuation`任何时间调用都会继续计算的过程。多次重入也会有相同的结果。听起来就很厉害的样子，所以，我也还没有完全搞明白。有了这样强大的结构，函数的执行过程就会变得很复杂，因为计算的过程不一定是线性的了。函数就像是一个一个有插孔和插槽的盒子，通过这些插孔和插槽可以把函数任意组合。

##### The End
说了这么些，已经忘了最开始写这个的目的了，也许是因为大促值班有点无聊，也许是因为喝了红牛还是很困，整个人有点懵逼。cps，或者`Continuation`，是个很有意思的概念，通过这个结构，我们可以理解甚至构造出很多好玩的东西，就像回调函数，promise, yield，不为别的，玩得开心很重要。下笔千言，离题万里，权当是个玩笑罢。